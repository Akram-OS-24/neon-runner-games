<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Neon Runner - Endless Adventure!</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); overflow: hidden; height: 100vh; }
    #gameContainer { position: relative; width: 100vw; height: 100vh; background: linear-gradient(180deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%); }
    canvas { display: block; background: transparent; }
    .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    .game-ui { position: absolute; top: 20px; left: 20px; color: #00ffff; font-size: 18px; text-shadow: 0 0 10px #00ffff; pointer-events: auto; }
    .score-display { font-size: 24px; margin-bottom: 10px; }
    .speed-display { font-size: 16px; opacity: 0.8; }
    .health-bar { position: absolute; top: 20px; right: 20px; width: 200px; height: 20px; background: rgba(255, 255, 255, 0.2); border-radius: 10px; overflow: hidden; border: 2px solid #00ffff; }
    .health-fill { height: 100%; background: linear-gradient(90deg, #ff4444, #ffaa00, #44ff44); transition: width 0.3s ease; border-radius: 8px; }
    .power-ups { position: absolute; bottom: 80px; left: 20px; display: flex; gap: 10px; }
    .power-up-icon { width: 50px; height: 50px; background: rgba(255, 255, 255, 0.2); border-radius: 25px; display: flex; align-items: center; justify-content: center; font-size: 24px; border: 2px solid #00ffff; transition: all 0.3s ease; }
    .power-up-icon.active { background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 20px #00ffff; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { transform: scale(3000); } 50% { transform: scale(300); } }
    .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; pointer-events: auto; }
    .control-btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.2); border: 2px solid #00ffff; border-radius: 50%; color: #00ffff; font-size: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; user-select: none; touch-action: manipulation; }
    .control-btn:active, .control-btn:hover { transform: scale(0.9); background: rgba(0, 255, 255, 0.3); box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
    .game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 40px; border-radius: 20px; text-align: center; border: 3px solid #ff0080; box-shadow: 0 0 30px rgba(255, 0, 128, 0.5); display: none; pointer-events: auto; z-index: 20; }
    .game-over h2 { color: #ff0080; margin-bottom: 20px; font-size: 32px; }
    .final-stats { margin: 20px 0; font-size: 18px; }
    .restart-btn, .upgrade-btn { background: linear-gradient(45deg, #ff0080, #00ffff); border: none; color: white; padding: 12px 24px; font-size: 16px; border-radius: 25px; cursor: pointer; margin: 10px; transition: all 0.3s ease; }
    .restart-btn:hover, .upgrade-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 0, 128, 0.5); }
    .pause-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); color: white; padding: 30px; border-radius: 20px; text-align: center; border: 3px solid #00ffff; display: none; pointer-events: auto; z-index: 20; }
    .upgrades-panel { max-height: 300px; overflow-y: auto; margin: 20px 0; }
    .upgrade-item { background: rgba(255, 255, 255, 0.1); margin: 10px 0; padding: 15px; border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.2); }
    .ad-banner { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); width: 320px; height: 50px; background: rgba(0, 0, 0, 0.8); border: 2px dashed #00ffff; color: #00ffff; display: flex; align-items: center; justify-content: center; font-size: 12px; }
    .interstitial { position: absolute; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 30; }
    .interstitial .box { background: #111; border: 2px solid #00ffff; color: #00ffff; padding: 24px; border-radius: 12px; text-align: center; width: 320px; }
    .interstitial button { margin-top: 12px; padding: 8px 16px; border-radius: 8px; border: 1px solid #00ffff; background: transparent; color: #00ffff; cursor: pointer; }

    @media (max-width: 768px) {
      .controls { bottom: 80px; }
      .control-btn { width: 50px; height: 50px; font-size: 20px; }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <nav style="position: absolute; top: 10px; right: 10px; z-index: 100;">
      <a href="about.html" style="color: #00ffff; text-decoration: none; margin: 0 10px; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 5px; font-size: 14px;">√Ä Propos</a>
      <a href="contact.html" style="color: #00ffff; text-decoration: none; margin: 0 10px; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 5px; font-size: 14px;">Contact</a>
      <a href="privacy.html" style="color: #00ffff; text-decoration: none; margin: 0 10px; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 5px; font-size: 14px;">Confidentialit√©</a>
      <a href="terms.html" style="color: #00ffff; text-decoration: none; margin: 0 10px; background: rgba(0,0,0,0.7); padding: 8px 15px; border-radius: 5px; font-size: 14px;">Conditions</a>
    </nav>

    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
      <div class="game-ui">
        <div class="score-display">Score: <span id="score">0</span></div>
        <div>Distance: <span id="distance">0</span>m</div>
        <div class="speed-display">Speed: <span id="speed">5</span></div>
        <div>Coins: <span id="coins">0</span></div>
      </div>

      <div class="health-bar"><div class="health-fill" id="healthFill"></div></div>

      <div class="power-ups" id="powerUps">
        <div class="power-up-icon" id="shield">üõ°Ô∏è</div>
        <div class="power-up-icon" id="speedPU">‚ö°</div>
        <div class="power-up-icon" id="magnet">üß≤</div>
        <div class="power-up-icon" id="jump">üöÄ</div>
      </div>

      <div class="controls">
        <div class="control-btn" id="leftBtn">‚Üê</div>
        <div class="control-btn" id="jumpBtn">‚Üë</div>
        <div class="control-btn" id="rightBtn">‚Üí</div>
        <div class="control-btn" id="pauseBtn">‚è∏Ô∏è</div>
      </div>
    </div>

    <div class="game-over" id="gameOver">
      <h2>Game Over!</h2>
      <div class="final-stats">
        <div>Final Score: <span id="finalScore">0</span></div>
        <div>Distance: <span id="finalDistance">0</span>m</div>
        <div>Coins Collected: <span id="finalCoins">0</span></div>
        <div>Best Score: <span id="bestScore">0</span></div>
      </div>
      <button class="restart-btn" onclick="restartGame()">Play Again</button>
      <button class="upgrade-btn" onclick="showUpgrades()">Upgrades</button>
      <button class="restart-btn" onclick="shareScore()">Share</button>
    </div>

    <div class="pause-menu" id="pauseMenu">
      <h3>Game Paused</h3>
      <button class="restart-btn" onclick="resumeGame()">Resume</button>
      <button class="upgrade-btn" onclick="showUpgrades()">Upgrades</button>
      <button class="restart-btn" onclick="restartGame()">Restart</button>
    </div>

    <div class="ad-banner">[Mobile Banner Ad - 320x50]</div>

    <div class="interstitial" id="interstitialAd">
      <div class="box">
        <div style="font-weight:bold; margin-bottom:8px;">Interstitial</div>
        Your ad could be here.
        <div><button onclick="closeInterstitialAd()">Close</button></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ===== Helpers for CSS vs device pixels =====
    const DPR = () => (window.devicePixelRatio || 1);
    const viewW = () => canvas.width / DPR();
    const viewH = () => canvas.height / DPR();

    // ===== Ground constants =====
    const GROUND_HEIGHT = 100; // visual thickness
    const groundTop = () => viewH() - GROUND_HEIGHT; // top surface in CSS pixels

    // Responsive + HiDPI canvas
    function resizeCanvas() {
      const dpr = DPR();
      // set CSS size
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      // set backing store size
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      // scale so 1 unit = 1 CSS pixel
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Snap player back to ground if needed
      const groundYForPlayer = groundTop() - game.player.height;
      if (game.player.y > groundYForPlayer) {
        game.player.y = Math.round(groundYForPlayer);
        game.player.velocityY = 0;
        game.player.onGround = true;
      }
      // Re-seat obstacles on the surface
      game.obstacles.forEach(o => { o.y = Math.round(groundTop() - o.height); });
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    let game = {
      player: { x: 100, y: 0, width: 40, height: 40, velocityY: 0, onGround: false, health: 100, maxHealth: 100 },
      camera: { x: 0 },
      obstacles: [], powerUps: [], coins: [], particles: [],
      score: 0, distance: 0, speed: 5, coinsCollected: 0,
      totalCoins: parseInt(localStorage.getItem('neonRunnerCoins') || '0'),
      bestScore: parseInt(localStorage.getItem('neonRunnerBest') || '0'),
      gameRunning: true, paused: false, keys: {},
      powerUpStates: { shield: { active: false, duration: 0 }, speed: { active: false, duration: 0 }, magnet: { active: false, duration: 0 }, jump: { active: false, duration: 0 } },
      upgrades: { health: parseInt(localStorage.getItem('upgradeHealth') || '0'), speed: parseInt(localStorage.getItem('upgradeSpeed') || '0'), jump: parseInt(localStorage.getItem('upgradeJump') || '0'), magnet: parseInt(localStorage.getItem('upgradeMagnet') || '0') }
    };

    // Controls
    const controls = { left: false, right: false, jump: false };
    function addControlEvents(elementId, controlKey) {
      const element = document.getElementById(elementId);
      element.addEventListener('touchstart', e => { e.preventDefault(); controls[controlKey] = true; });
      element.addEventListener('touchend',   e => { e.preventDefault(); controls[controlKey] = false; });
      element.addEventListener('mousedown',  e => { e.preventDefault(); controls[controlKey] = true; });
      element.addEventListener('mouseup',    e => { e.preventDefault(); controls[controlKey] = false; });
      element.addEventListener('mouseleave', e => { e.preventDefault(); controls[controlKey] = false; });
    }
    addControlEvents('leftBtn', 'left');
    addControlEvents('rightBtn', 'right');
    addControlEvents('jumpBtn', 'jump');

    document.getElementById('pauseBtn').addEventListener('click', togglePause);

    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'ArrowLeft': case 'KeyA': controls.left = true; break;
        case 'ArrowRight': case 'KeyD': controls.right = true; break;
        case 'ArrowUp': case 'KeyW': case 'Space': e.preventDefault(); controls.jump = true; break;
        case 'KeyP': togglePause(); break;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'ArrowLeft': case 'KeyA': controls.left = false; break;
        case 'ArrowRight': case 'KeyD': controls.right = false; break;
        case 'ArrowUp': case 'KeyW': case 'Space': controls.jump = false; break;
      }
    });

    function createObstacle() {
      const types = ['spike', 'block', 'laser'];
      const type = types[Math.floor(Math.random() * types.length)];
      const height = 40 + Math.random() * 40;
      return {
        x: game.camera.x + viewW() + Math.random() * 200,
        y: Math.round(groundTop() - height),
        width: 40,
        height,
        type,
        color: type === 'spike' ? '#ff4444' : type === 'block' ? '#ff8800' : '#ff0080'
      };
    }

    function createPowerUp() {
      const types = ['shield', 'speed', 'magnet', 'jump', 'health'];
      const type = types[Math.floor(Math.random() * types.length)];
      return { x: game.camera.x + viewW() + Math.random() * 300, y: groundTop() - 100 - Math.random() * 100, width: 30, height: 30, type, collected: false, animation: 0 };
    }

    function createCoin() {
      return { x: game.camera.x + viewW() + Math.random() * 200, y: groundTop() - 50 - Math.random() * 150, width: 20, height: 20, collected: false, animation: 0, value: 1 };
    }

    function createParticle(x, y, color) { return { x, y, vx: (Math.random() - 0.5) * 10, vy: Math.random() * -10 - 5, life: 1.0, color, size: Math.random() * 8 + 2 }; }

    function updatePlayer() {
      const W = viewW();
      if (controls.left && game.player.x > game.camera.x + 20) game.player.x -= 8;
      if (controls.right && game.player.x < game.camera.x + W - game.player.width - 20) game.player.x += 8;

      if (controls.jump && game.player.onGround) {
        const jumpPower = 22 + (game.upgrades.jump * 3);
        game.player.velocityY = -jumpPower;
        game.player.onGround = false;
        for (let i = 0; i < 5; i++) game.particles.push(createParticle(game.player.x + game.player.width / 2, game.player.y + game.player.height, '#00ffff'));
      }

      game.player.velocityY += 1.2; // gravity
      game.player.y += game.player.velocityY;

      const groundYForPlayer = groundTop() - game.player.height;
      if (game.player.y >= groundYForPlayer) { game.player.y = Math.round(groundYForPlayer); game.player.velocityY = 0; game.player.onGround = true; }
      else { game.player.onGround = false; }

      const targetCameraX = game.player.x - 200;
      game.camera.x += (targetCameraX - game.camera.x) * 0.1;

      const currentSpeed = game.speed + (game.powerUpStates.speed.active ? 3 : 0);
      game.player.x += currentSpeed;
      game.distance += currentSpeed / 10;

      if (Math.floor(game.distance) % 100 === 0 && game.distance > 0) game.speed += 0.05;
    }

    function updateObstacles() {
      if (Math.random() < 0.01 + (game.speed / 1000)) game.obstacles.push(createObstacle());
      game.obstacles.forEach((o, i) => {
        if (o.x < game.camera.x - 100) { game.obstacles.splice(i, 1); game.score += 10; return; }
        if (!game.powerUpStates.shield.active &&
            game.player.x < o.x + o.width && game.player.x + game.player.width > o.x &&
            game.player.y < o.y + o.height && game.player.y + game.player.height > o.y) {
          game.player.health -= 20;
          for (let k = 0; k < 10; k++) game.particles.push(createParticle(game.player.x + game.player.width / 2, game.player.y + game.player.height / 2, '#ff4444'));
          game.obstacles.splice(i, 1);
          if (game.player.health <= 0) gameOver();
        }
      });
    }

    function updatePowerUps() {
      if (Math.random() < 0.005) game.powerUps.push(createPowerUp());
      game.powerUps.forEach((p, i) => {
        p.animation += 0.1;
        if (p.x < game.camera.x - 100) { game.powerUps.splice(i, 1); return; }
        if (game.powerUpStates.magnet.active) {
          const dx = game.player.x - p.x, dy = game.player.y - p.y; const dist = Math.hypot(dx, dy);
          if (dist < 100) { p.x += dx * 0.1; p.y += dy * 0.1; }
        }
        if (game.player.x < p.x + p.width && game.player.x + game.player.width > p.x && game.player.y < p.y + p.height && game.player.y + game.player.height > p.y) {
          activatePowerUp(p.type);
          game.powerUps.splice(i, 1);
          for (let k = 0; k < 15; k++) game.particles.push(createParticle(p.x + p.width / 2, p.y + p.height / 2, '#00ffff'));
        }
      });
      Object.keys(game.powerUpStates).forEach(key => { if (game.powerUpStates[key].active) { game.powerUpStates[key].duration--; if (game.powerUpStates[key].duration <= 0) game.powerUpStates[key].active = false; } });
    }

    function updateCoins() {
      if (Math.random() < 0.02) game.coins.push(createCoin());
      game.coins.forEach((c, i) => {
        c.animation += 0.15;
        if (c.x < game.camera.x - 100) { game.coins.splice(i, 1); return; }
        if (game.powerUpStates.magnet.active) {
          const dx = game.player.x - c.x, dy = game.player.y - c.y; const dist = Math.hypot(dx, dy);
          if (dist < 150) { c.x += dx * 0.15; c.y += dy * 0.15; }
        }
        if (game.player.x < c.x + c.width && game.player.x + game.player.width > c.x && game.player.y < c.y + c.height && game.player.y + game.player.height > c.y) {
          game.coinsCollected += c.value; game.totalCoins++; game.score += 5; game.coins.splice(i, 1);
          for (let k = 0; k < 8; k++) game.particles.push(createParticle(c.x + c.width / 2, c.y + c.height / 2, '#ffff00'));
        }
      });
    }

    function updateParticles() { game.particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.vy += 0.5; p.life -= 0.02; if (p.life <= 0) game.particles.splice(i, 1); }); }

    function activatePowerUp(type) {
      switch (type) {
        case 'shield': game.powerUpStates.shield.active = true; game.powerUpStates.shield.duration = 300; break;
        case 'speed':  game.powerUpStates.speed.active = true;  game.powerUpStates.speed.duration = 600; break;
        case 'magnet': game.powerUpStates.magnet.active = true; game.powerUpStates.magnet.duration = 450; break;
        case 'jump':   game.powerUpStates.jump.active = true;   game.powerUpStates.jump.duration = 400; break;
        case 'health': game.player.health = Math.min(game.player.maxHealth, game.player.health + 30); break;
      }
    }

    function draw() {
      const W = viewW();
      const H = viewH();

      ctx.clearRect(0, 0, W, H);

      // Background gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, H);
      gradient.addColorStop(0, '#1a1a2e'); gradient.addColorStop(0.5, '#16213e'); gradient.addColorStop(1, '#0f3460');
      ctx.fillStyle = gradient; ctx.fillRect(0, 0, W, H);

      // Moving grid
      ctx.s



